name: Generate Conversation Index

on:
  push:
    branches:
      - main
    paths:
      - 'conversations/*.md'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate-index:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate conversations index
        run: |
          # Generate array of conversation objects with metadata
          CONVERSATIONS=()

          for file in conversations/*.md; do
            # Skip README and template files
            [[ "$file" == "conversations/README.md" ]] && continue
            [[ "$file" =~ conversations/templates/ ]] && continue
            [[ ! -f "$file" ]] && continue

            FILENAME=$(basename "$file")

            # Extract metadata from file
            TITLE=$(head -n 1 "$file" | sed 's/^#\s*Conversation:\s*//' | sed 's/^#\s*//')
            STATUS=$(grep "^\*\*Status\*\*" "$file" | head -1 | sed 's/.*`\([^`]*\)`.*/\1/')
            STARTED=$(grep "^\*\*Started\*\*" "$file" | head -1 | sed 's/^.*:\s*//')

            # Get last modified date from git
            LAST_MODIFIED=$(git log -1 --format=%cI "$file" 2>/dev/null || date -Iseconds)

            # Count messages (## headers)
            MESSAGE_COUNT=$(grep -c "^## " "$file" || echo "0")

            # Extract participants
            PARTICIPANTS=$(awk '/^\*\*Participants\*\*:/,/^---$/ {if ($0 ~ /^- /) print}' "$file" | sed 's/^- //' | sed 's/ (Claude[^)]*)//g' | jq -R -s -c 'split("\n") | map(select(length > 0))' || echo "[]")

            # Extract excerpt (first non-header paragraph after metadata)
            EXCERPT=$(awk '/^---$/,/^## / {next} /^##/ {flag=1; next} flag && NF {print; exit}' "$file" | head -c 150 | sed 's/"/\\"/g')
            [[ ${#EXCERPT} -ge 150 ]] && EXCERPT="${EXCERPT}..."

            # Default values if extraction failed
            [[ -z "$TITLE" ]] && TITLE=$(echo "$FILENAME" | sed 's/.md$//' | sed 's/-/ /g')
            [[ -z "$STATUS" ]] && STATUS="open"
            [[ -z "$STARTED" ]] && STARTED="2026-01-31"

            # Build JSON object
            JSON_OBJ=$(jq -n \
              --arg fn "$FILENAME" \
              --arg title "$TITLE" \
              --arg status "$STATUS" \
              --arg started "$STARTED" \
              --arg modified "$LAST_MODIFIED" \
              --argjson participants "$PARTICIPANTS" \
              --arg excerpt "$EXCERPT" \
              --argjson count "$MESSAGE_COUNT" \
              '{
                filename: $fn,
                title: $title,
                status: $status,
                started: $started,
                lastModified: $modified,
                participants: $participants,
                excerpt: $excerpt,
                messageCount: $count
              }')

            CONVERSATIONS+=("$JSON_OBJ")
          done

          # Combine all conversations into array and sort by lastModified (descending)
          printf '%s\n' "${CONVERSATIONS[@]}" | jq -s 'sort_by(.lastModified) | reverse' > conversations/conversations.tmp.json

          # Add lastUpdated timestamp and create final JSON
          jq -n \
            --slurpfile convs conversations/conversations.tmp.json \
            --arg updated "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{conversations: $convs[0], lastUpdated: $updated}' \
            > conversations/index.json

          rm conversations/conversations.tmp.json

      - name: Commit and push index
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          if git diff --quiet conversations/index.json; then
            echo "No changes to conversations/index.json"
            exit 0
          fi

          git add conversations/index.json
          git commit -m "Auto-update conversation index [skip ci]"
          git push
