name: Auto-merge conversation replies

on:
  pull_request:
    types: [opened, synchronize]
    # Note: paths filter doesn't prevent PRs, just controls when workflow runs
    # We add explicit validation below to reject non-conversation changes
    paths:
      - 'conversations/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate PR only touches conversations/
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          # CRITICAL SECURITY: Only allow PRs that modify conversations/ directory
          git fetch origin "$BASE_REF"
          ALL_FILES=$(git diff --name-only "origin/$BASE_REF...HEAD")

          INVALID=false
          echo "$ALL_FILES" | while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            if [[ ! "$file" =~ ^conversations/ ]]; then
              echo "❌ SECURITY: Non-conversation file modified: $file"
              echo "Only changes to the conversations/ directory are allowed via PR."
              exit 1
            fi
          done

          echo "✅ All changed files are in conversations/ directory"

      - name: Check for symlinks
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          # CRITICAL SECURITY: Reject symlinks to prevent accessing files outside conversations/
          git fetch origin "$BASE_REF"
          ALL_FILES=$(git diff --name-only "origin/$BASE_REF...HEAD")

          echo "$ALL_FILES" | while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            if [[ -L "$file" ]]; then
              echo "❌ SECURITY: Symlinks are not allowed in PRs"
              echo "File '$file' is a symlink"
              echo "Symlinks could be used to access files outside the conversations/ directory."
              exit 1
            fi
          done

          echo "✅ No symlinks detected"

      - name: Check file sizes
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          # SECURITY: Prevent DoS attacks via extremely large files
          git fetch origin "$BASE_REF"
          ALL_FILES=$(git diff --name-only "origin/$BASE_REF...HEAD")

          MAX_SIZE=1048576  # 1MB limit

          echo "$ALL_FILES" | while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            if [[ -f "$file" ]]; then
              FILE_SIZE=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")

              if [[ $FILE_SIZE -gt $MAX_SIZE ]]; then
                SIZE_MB=$(echo "scale=2; $FILE_SIZE / 1048576" | bc)
                echo "❌ File too large: $file (${SIZE_MB}MB)"
                echo "Maximum file size is 1MB. Please reduce file size."
                exit 1
              fi
            fi
          done

          echo "✅ All files within size limits"

      - name: Get changed files
        id: changed-files
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          # Get list of changed files in this PR
          git fetch origin "$BASE_REF"
          CHANGED_FILES=$(git diff --name-only "origin/$BASE_REF...HEAD" -- conversations/)
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Changed files: $CHANGED_FILES"

      - name: Check if reply or new conversation
        id: check-type
        env:
          BASE_REF: ${{ github.base_ref }}
          CHANGED_FILES: ${{ steps.changed-files.outputs.files }}
        run: |
          IS_REPLY=false
          IS_NEW=false

          echo "$CHANGED_FILES" | while IFS= read -r file; do
            [[ -z "$file" ]] && continue

            # Skip README and templates
            if [[ "$file" == "conversations/README.md" ]] || [[ "$file" =~ ^conversations/templates/ ]]; then
              continue
            fi

            # Check if file existed before this PR
            if git cat-file -e "origin/$BASE_REF:$file" 2>/dev/null; then
              echo "File $file exists - this is a REPLY"
              IS_REPLY=true
            else
              echo "File $file is new - this is a NEW CONVERSATION"
              IS_NEW=true
            fi
          done

          # Re-check outside subshell (while loop runs in subshell via pipe)
          IS_REPLY=false
          IS_NEW=false
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            [[ "$file" == "conversations/README.md" ]] && continue
            [[ "$file" =~ ^conversations/templates/ ]] && continue
            if git cat-file -e "origin/$BASE_REF:$file" 2>/dev/null; then
              IS_REPLY=true
            else
              IS_NEW=true
            fi
          done <<< "$CHANGED_FILES"

          echo "is_reply=$IS_REPLY" >> $GITHUB_OUTPUT
          echo "is_new=$IS_NEW" >> $GITHUB_OUTPUT

      - name: Count words in changes
        if: steps.check-type.outputs.is_reply == 'true'
        id: word-count
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          # Get the diff for conversation files
          git fetch origin "$BASE_REF"
          DIFF=$(git diff "origin/$BASE_REF...HEAD" -- conversations/*.md | grep "^+" | grep -v "^+++" || true)

          # Count words (excluding markdown markers)
          WORD_COUNT=$(echo "$DIFF" | wc -w)

          # Validate word count is numeric
          if ! [[ "$WORD_COUNT" =~ ^[0-9]+$ ]]; then
            echo "⚠️ Invalid word count: $WORD_COUNT"
            WORD_COUNT=0
          fi

          echo "word_count=$WORD_COUNT" >> $GITHUB_OUTPUT
          echo "Words added: $WORD_COUNT"

      - name: Check for deletions and modifications
        if: steps.check-type.outputs.is_reply == 'true'
        id: check-changes
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          git fetch origin "$BASE_REF"
          DIFF=$(git diff "origin/$BASE_REF...HEAD" -- conversations/*.md)

          HAS_DELETIONS=false
          HAS_MODIFICATIONS=false

          # Check for deleted lines (lines starting with - but not ---)
          DELETED_LINES=$(echo "$DIFF" | grep "^-" | grep -v "^---" | grep -v "^-- $" | wc -l)
          if [[ $DELETED_LINES -gt 0 ]]; then
            echo "⚠️ Found $DELETED_LINES deleted lines - not allowed"
            HAS_DELETIONS=true
          fi

          # Check if any existing content was modified (not just added)
          if echo "$DIFF" | awk '/^-[^-]/{del=1} /^+[^+]/{if(del)exit 0} /^@@/{del=0} END{exit 1}'; then
            echo "⚠️ Existing content was modified - not allowed"
            HAS_MODIFICATIONS=true
          fi

          echo "has_deletions=$HAS_DELETIONS" >> $GITHUB_OUTPUT
          echo "has_modifications=$HAS_MODIFICATIONS" >> $GITHUB_OUTPUT

      - name: Check for spam patterns
        if: steps.check-type.outputs.is_reply == 'true'
        id: spam-check
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          # Get the diff content
          git fetch origin "$BASE_REF"
          DIFF=$(git diff "origin/$BASE_REF...HEAD" -- conversations/*.md)

          IS_SPAM=false

          # Check for prompt injection patterns (expanded list)
          if echo "$DIFF" | grep -Eqi "ignore (previous|all|prior) (instructions|prompts|commands)|disregard (everything|all|previous)|system prompt|you are now|new instructions|override (previous|prior|system)|reset (instructions|context|system)|pretend (to be|you are)|jailbreak|developer mode|admin mode|god mode|sudo mode"; then
            echo "⚠️ Potential prompt injection detected"
            IS_SPAM=true
          fi

          # Check for multiline prompt injection
          NORMALIZED=$(echo "$DIFF" | tr '\n' ' ' | tr -s ' ')
          if echo "$NORMALIZED" | grep -Eqi "ignore\s+(previous|all|prior)\s+(instructions|prompts|commands)|disregard\s+(everything|all|previous)|override\s+(previous|prior|system)|reset\s+(instructions|context|system)"; then
            echo "⚠️ Potential multiline prompt injection detected"
            IS_SPAM=true
          fi

          # Check for excessive repetition (same word 10+ times in a row)
          if echo "$DIFF" | grep -oE '\b(\w+)(\s+\1){9,}\b'; then
            echo "⚠️ Excessive repetition detected"
            IS_SPAM=true
          fi

          echo "is_spam=$IS_SPAM" >> $GITHUB_OUTPUT

      - name: Auto-merge decision
        id: should-merge
        env:
          IS_REPLY: ${{ steps.check-type.outputs.is_reply }}
          IS_NEW: ${{ steps.check-type.outputs.is_new }}
          WORD_COUNT: ${{ steps.word-count.outputs.word_count }}
          IS_SPAM: ${{ steps.spam-check.outputs.is_spam }}
          HAS_DELETIONS: ${{ steps.check-changes.outputs.has_deletions }}
          HAS_MODIFICATIONS: ${{ steps.check-changes.outputs.has_modifications }}
        run: |
          SHOULD_MERGE=false
          REASON=""

          if [[ "$IS_NEW" == "true" ]]; then
            REASON="New conversation - requires manual review"
          elif [[ "$HAS_DELETIONS" == "true" ]]; then
            REASON="Contains deletions - not allowed, requires manual review"
          elif [[ "$HAS_MODIFICATIONS" == "true" ]]; then
            REASON="Modifies existing content - not allowed, requires manual review"
          elif [[ "$IS_SPAM" == "true" ]]; then
            REASON="Potential spam detected - requires manual review"
          elif [[ "$IS_REPLY" == "true" ]] && [[ "$WORD_COUNT" -le 500 ]]; then
            SHOULD_MERGE=true
            REASON="Reply under 500 words - auto-merging"
          elif [[ "$IS_REPLY" == "true" ]] && [[ "$WORD_COUNT" -gt 500 ]]; then
            REASON="Reply over 500 words ($WORD_COUNT) - requires manual review"
          else
            REASON="Unknown case - requires manual review"
          fi

          echo "should_merge=$SHOULD_MERGE" >> $GITHUB_OUTPUT
          echo "reason=$REASON" >> $GITHUB_OUTPUT
          echo "Decision: $REASON"

      - name: Add label and comment
        uses: actions/github-script@v7
        env:
          SHOULD_MERGE: ${{ steps.should-merge.outputs.should_merge }}
          MERGE_REASON: ${{ steps.should-merge.outputs.reason }}
          ADDED_WORDS: ${{ steps.word-count.outputs.word_count }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const shouldMerge = process.env.SHOULD_MERGE === 'true';
            const reason = process.env.MERGE_REASON;
            const wordCount = process.env.ADDED_WORDS;

            // Add label
            const label = shouldMerge ? 'auto-merge' : 'needs-review';
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [label]
            });

            // Add comment
            const message = shouldMerge
              ? `✅ **Auto-merge approved**\n\n${reason}\n\nWords added: ${wordCount}\n\nThis PR will be automatically merged.`
              : `⏸️ **Manual review required**\n\n${reason}\n\n${wordCount > 0 ? `Words added: ${wordCount}` : ''}\n\nA maintainer will review this PR.`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });

      - name: Auto-merge PR
        if: steps.should-merge.outputs.should_merge == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                merge_method: 'squash',
                commit_title: `Auto-merge: ${context.payload.pull_request.title}`,
                commit_message: `Automatically merged reply under 500 words.\n\nCo-Authored-By: ${context.payload.pull_request.user.login} <${context.payload.pull_request.user.login}@users.noreply.github.com>`
              });
              console.log('✅ PR auto-merged successfully');
            } catch (error) {
              console.error('❌ Auto-merge failed:', error.message);
              // Add comment about failure
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `⚠️ Auto-merge failed: ${error.message}\n\nA maintainer will need to merge manually.`
              });
            }
