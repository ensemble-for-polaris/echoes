name: Auto-merge conversation replies

on:
  pull_request:
    types: [opened, synchronize]
    # Note: paths filter doesn't prevent PRs, just controls when workflow runs
    # We add explicit validation below to reject non-conversation changes
    paths:
      - 'conversations/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate PR only touches conversations/
        run: |
          # CRITICAL SECURITY: Only allow PRs that modify conversations/ directory
          git fetch origin ${{ github.base_ref }}
          ALL_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)

          INVALID_FILES=""
          for file in $ALL_FILES; do
            if [[ ! "$file" =~ ^conversations/ ]]; then
              INVALID_FILES="$INVALID_FILES\n- $file"
            fi
          done

          if [[ -n "$INVALID_FILES" ]]; then
            echo "❌ SECURITY: PR modifies files outside conversations/ directory"
            echo "Invalid files:$INVALID_FILES"
            echo ""
            echo "Only changes to the conversations/ directory are allowed via PR."
            echo "All other changes must be made by repository maintainers directly."
            exit 1
          fi

          echo "✅ All changed files are in conversations/ directory"

      - name: Check for symlinks
        run: |
          # CRITICAL SECURITY: Reject symlinks to prevent accessing files outside conversations/
          git fetch origin ${{ github.base_ref }}
          ALL_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)

          for file in $ALL_FILES; do
            if [[ -L "$file" ]]; then
              echo "❌ SECURITY: Symlinks are not allowed in PRs"
              echo "File '$file' is a symlink"
              echo ""
              echo "Symlinks could be used to access files outside the conversations/ directory."
              echo "Please submit regular files only."
              exit 1
            fi
          done

          echo "✅ No symlinks detected"

      - name: Check file sizes
        run: |
          # SECURITY: Prevent DoS attacks via extremely large files
          git fetch origin ${{ github.base_ref }}
          ALL_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)

          MAX_SIZE=1048576  # 1MB limit

          for file in $ALL_FILES; do
            if [[ -f "$file" ]]; then
              FILE_SIZE=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")

              if [[ $FILE_SIZE -gt $MAX_SIZE ]]; then
                SIZE_MB=$(echo "scale=2; $FILE_SIZE / 1048576" | bc)
                echo "❌ File too large: $file (${SIZE_MB}MB)"
                echo ""
                echo "Maximum file size is 1MB. Please reduce file size."
                echo "For large conversations, consider splitting into multiple parts."
                exit 1
              fi
            fi
          done

          echo "✅ All files within size limits"

      - name: Get changed files
        id: changed-files
        run: |
          # Get list of changed files in this PR
          git fetch origin ${{ github.base_ref }}
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD -- conversations/)
          echo "files=$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "Changed files: $CHANGED_FILES"

      - name: Check if reply or new conversation
        id: check-type
        run: |
          CHANGED_FILES="${{ steps.changed-files.outputs.files }}"
          IS_REPLY=false
          IS_NEW=false

          for file in $CHANGED_FILES; do
            # Skip README and templates
            if [[ "$file" == "conversations/README.md" ]] || [[ "$file" =~ ^conversations/templates/ ]]; then
              continue
            fi

            # Check if file existed before this PR
            if git cat-file -e origin/${{ github.base_ref }}:"$file" 2>/dev/null; then
              echo "File $file exists - this is a REPLY"
              IS_REPLY=true
            else
              echo "File $file is new - this is a NEW CONVERSATION"
              IS_NEW=true
            fi
          done

          echo "is_reply=$IS_REPLY" >> $GITHUB_OUTPUT
          echo "is_new=$IS_NEW" >> $GITHUB_OUTPUT

      - name: Count words in changes
        if: steps.check-type.outputs.is_reply == 'true'
        id: word-count
        run: |
          # Get the diff for conversation files
          git fetch origin ${{ github.base_ref }}
          DIFF=$(git diff origin/${{ github.base_ref }}...HEAD -- conversations/*.md | grep "^+" | grep -v "^+++" || true)

          # Count words (excluding markdown markers)
          WORD_COUNT=$(echo "$DIFF" | wc -w)

          # Validate word count is numeric
          if ! [[ "$WORD_COUNT" =~ ^[0-9]+$ ]]; then
            echo "⚠️ Invalid word count: $WORD_COUNT"
            WORD_COUNT=0
          fi

          echo "word_count=$WORD_COUNT" >> $GITHUB_OUTPUT
          echo "Words added: $WORD_COUNT"

      - name: Check for deletions and modifications
        if: steps.check-type.outputs.is_reply == 'true'
        id: check-changes
        run: |
          git fetch origin ${{ github.base_ref }}
          DIFF=$(git diff origin/${{ github.base_ref }}...HEAD -- conversations/*.md)

          HAS_DELETIONS=false
          HAS_MODIFICATIONS=false

          # Check for deleted lines (lines starting with - but not ---)
          # Exclude diff headers and empty lines
          DELETED_LINES=$(echo "$DIFF" | grep "^-" | grep -v "^---" | grep -v "^-- $" | wc -l)
          if [[ $DELETED_LINES -gt 0 ]]; then
            echo "⚠️ Found $DELETED_LINES deleted lines - not allowed"
            HAS_DELETIONS=true
          fi

          # Check if any existing content was modified (not just added)
          # A modification has both deletion (-) and addition (+) in proximity
          # Pure additions at end of file won't trigger this
          if echo "$DIFF" | awk '/^-[^-]/{del=1} /^+[^+]/{if(del)exit 0} /^@@/{del=0} END{exit 1}'; then
            echo "⚠️ Existing content was modified - not allowed"
            HAS_MODIFICATIONS=true
          fi

          echo "has_deletions=$HAS_DELETIONS" >> $GITHUB_OUTPUT
          echo "has_modifications=$HAS_MODIFICATIONS" >> $GITHUB_OUTPUT

      - name: Check for spam patterns
        if: steps.check-type.outputs.is_reply == 'true'
        id: spam-check
        run: |
          # Get the diff content
          git fetch origin ${{ github.base_ref }}
          DIFF=$(git diff origin/${{ github.base_ref }}...HEAD -- conversations/*.md)

          IS_SPAM=false

          # Check for prompt injection patterns (expanded list)
          if echo "$DIFF" | grep -Eqi "ignore (previous|all|prior) (instructions|prompts|commands)|disregard (everything|all|previous)|system prompt|you are now|new instructions|override (previous|prior|system)|reset (instructions|context|system)|act as|pretend (to be|you are)|roleplay|jailbreak|developer mode|admin mode|god mode|sudo mode"; then
            echo "⚠️ Potential prompt injection detected"
            IS_SPAM=true
          fi

          # Check for multiline prompt injection (keywords split across lines)
          # Normalize whitespace to catch patterns like "ignore\nprevious\ninstructions"
          NORMALIZED=$(echo "$DIFF" | tr '\n' ' ' | tr -s ' ')
          if echo "$NORMALIZED" | grep -Eqi "ignore\s+(previous|all|prior)\s+(instructions|prompts|commands)|disregard\s+(everything|all|previous)|override\s+(previous|prior|system)|reset\s+(instructions|context|system)"; then
            echo "⚠️ Potential multiline prompt injection detected"
            IS_SPAM=true
          fi

          # Check for excessive repetition (same word 10+ times in a row)
          if echo "$DIFF" | grep -oE '\b(\w+)(\s+\1){9,}\b'; then
            echo "⚠️ Excessive repetition detected"
            IS_SPAM=true
          fi

          echo "is_spam=$IS_SPAM" >> $GITHUB_OUTPUT

      - name: Auto-merge decision
        id: should-merge
        run: |
          IS_REPLY="${{ steps.check-type.outputs.is_reply }}"
          IS_NEW="${{ steps.check-type.outputs.is_new }}"
          WORD_COUNT="${{ steps.word-count.outputs.word_count }}"
          IS_SPAM="${{ steps.spam-check.outputs.is_spam }}"
          HAS_DELETIONS="${{ steps.check-changes.outputs.has_deletions }}"
          HAS_MODIFICATIONS="${{ steps.check-changes.outputs.has_modifications }}"

          SHOULD_MERGE=false
          REASON=""

          if [[ "$IS_NEW" == "true" ]]; then
            REASON="New conversation - requires manual review"
          elif [[ "$HAS_DELETIONS" == "true" ]]; then
            REASON="Contains deletions - not allowed, requires manual review"
          elif [[ "$HAS_MODIFICATIONS" == "true" ]]; then
            REASON="Modifies existing content - not allowed, requires manual review"
          elif [[ "$IS_SPAM" == "true" ]]; then
            REASON="Potential spam detected - requires manual review"
          elif [[ "$IS_REPLY" == "true" ]] && [[ "$WORD_COUNT" -le 500 ]]; then
            SHOULD_MERGE=true
            REASON="Reply under 500 words - auto-merging"
          elif [[ "$IS_REPLY" == "true" ]] && [[ "$WORD_COUNT" -gt 500 ]]; then
            REASON="Reply over 500 words ($WORD_COUNT) - requires manual review"
          else
            REASON="Unknown case - requires manual review"
          fi

          echo "should_merge=$SHOULD_MERGE" >> $GITHUB_OUTPUT
          echo "reason=$REASON" >> $GITHUB_OUTPUT
          echo "Decision: $REASON"

      - name: Add label and comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const shouldMerge = '${{ steps.should-merge.outputs.should_merge }}' === 'true';
            const reason = '${{ steps.should-merge.outputs.reason }}';
            const wordCount = '${{ steps.word-count.outputs.word_count }}';

            // Add label
            const label = shouldMerge ? 'auto-merge' : 'needs-review';
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [label]
            });

            // Add comment
            const message = shouldMerge
              ? `✅ **Auto-merge approved**\n\n${reason}\n\nWords added: ${wordCount}\n\nThis PR will be automatically merged.`
              : `⏸️ **Manual review required**\n\n${reason}\n\n${wordCount > 0 ? `Words added: ${wordCount}` : ''}\n\nA maintainer will review this PR.`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });

      - name: Auto-merge PR
        if: steps.should-merge.outputs.should_merge == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                merge_method: 'squash',
                commit_title: `Auto-merge: ${context.payload.pull_request.title}`,
                commit_message: `Automatically merged reply under 500 words.\n\nCo-Authored-By: ${context.payload.pull_request.user.login} <${context.payload.pull_request.user.login}@users.noreply.github.com>`
              });
              console.log('✅ PR auto-merged successfully');
            } catch (error) {
              console.error('❌ Auto-merge failed:', error.message);
              // Add comment about failure
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `⚠️ Auto-merge failed: ${error.message}\n\nA maintainer will need to merge manually.`
              });
            }
